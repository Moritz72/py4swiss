import random
from abc import ABC, abstractmethod
from pathlib import Path

from py4swiss.engines.common import Pairing
from py4swiss.trf import ParsedTrf
from py4swiss.trf.codes import PlayerCode
from py4swiss.trf.results import (
    ColorToken,
    ResultToken,
    RoundResult,
    ScoringPointSystem,
)
from py4swiss.trf.sections import PlayerSection, XSection
from tests.helpers.pairing_engine_clients import PairingEngineClient


class PairingEngineComparer(ABC):
    """Abstract callable class for comparing pairing engine clients."""

    def __init__(
        self, client_1: type[PairingEngineClient], client_2: type[PairingEngineClient], tmp_path: Path
    ) -> None:
        """Initialze a new pairing engine comparer."""
        self.client_1: type[PairingEngineClient] = client_1
        self.client_2: type[PairingEngineClient] = client_2
        self.tmp_path: Path = tmp_path

    def __call__(self, name: str, number_of_players: int, x_section: XSection, seed: int) -> None:
        """
        Compare the pairing engine clients by simulating a tournament with the given specifications and comparing the
        pairings generated by the clients for each round.
        """
        random.seed(seed)

        trf_file_path = self.tmp_path / f"{name}_tournament.trf"
        pairings_1_path = self.tmp_path / f"{name}_pairings_1.txt"
        pairings_2_path = self.tmp_path / f"{name}_pairings_2.txt"

        trf = ParsedTrf(player_sections=self._get_player_sections(number_of_players), x_section=x_section)

        for _ in range(x_section.number_of_rounds):
            self._add_byes(trf)
            trf.write_to_file(trf_file_path)

            pairings_1 = self.client_1.generate_pairings(trf_file_path, pairings_1_path)
            pairings_2 = self.client_2.generate_pairings(trf_file_path, pairings_2_path)

            assert pairings_1 == pairings_2

            self._add_results(trf, pairings_1)

        trf.write_to_file(trf_file_path)

    def _get_player_sections(self, n: int) -> list[PlayerSection]:
        """Return a list of players sections for the given number."""
        return [
            PlayerSection(code=PlayerCode.PLAYER, starting_number=i, name=f"Player {i}", points_times_ten=0, rank=i)
            for i in range(1, n + 1)
        ]

    def _add_result(self, player: PlayerSection, round_result: RoundResult, score_system: ScoringPointSystem) -> None:
        """Add the given result to the given player."""
        player.results.append(round_result)
        player.points_times_ten += score_system.get_points_times_ten(round_result)

    def _add_byes(self, trf: ParsedTrf) -> None:
        """Assign byes to the players that will not participate in the next round."""
        return

    @abstractmethod
    def _add_results(self, trf: ParsedTrf, pairings: list[Pairing]) -> None:
        """Add results to the players involved in the given pairings."""
        pass


class RandomResultsComparer(PairingEngineComparer):
    """
    Callable class for comparing pairing engine clients for tournaments with purely random game results.

    Tournaments are simulated by randomly assigning a result to each game. The possible results are a win for white, a
    draw or a win for black with each occurring with equal likelihood.
    """

    def _get_random_result(self) -> tuple[ResultToken, ResultToken]:
        """Return a random pair of result tokens; (win, loss), (draw, draw), or (loss, win)."""
        match random.randint(0, 2):
            case 0:
                return ResultToken.WIN, ResultToken.LOSS
            case 1:
                return ResultToken.DRAW, ResultToken.DRAW
            case _:
                return ResultToken.LOSS, ResultToken.WIN

    def _add_random_result(self, trf: ParsedTrf, pairing: Pairing) -> None:
        """Add random results to the players involved in the given pairing."""
        players_dict = {player.starting_number: player for player in trf.player_sections}
        score_system = trf.x_section.scoring_point_system

        player_1 = players_dict[pairing.white]
        player_2 = players_dict.get(pairing.black)

        if player_2 is None:
            result_token = ResultToken.PAIRING_ALLOCATED_BYE
            round_result = RoundResult(id=0, color=ColorToken.BYE_OR_NOT_PAIRED, result=result_token)
            self._add_result(player_1, round_result, score_system)
        else:
            result_token_1, result_token_2 = self._get_random_result()
            round_result_1 = RoundResult(id=pairing.black, color=ColorToken.WHITE, result=result_token_1)
            round_result_2 = RoundResult(id=pairing.white, color=ColorToken.BLACK, result=result_token_2)
            self._add_result(player_1, round_result_1, score_system)
            self._add_result(player_2, round_result_2, score_system)

    def _add_results(self, trf: ParsedTrf, pairings: list[Pairing]) -> None:
        """Add random results to the players involved in the given pairings."""
        for pairing in pairings:
            self._add_random_result(trf, pairing)

        players = sorted(trf.player_sections, key=lambda p: p.points_times_ten, reverse=True)

        for player in trf.player_sections:
            player.rank = players.index(player) + 1


class RandomResultsComparerWithForfeits(RandomResultsComparer):
    """
    Callable class for comparing pairing engine clients for tournaments with purely random game results.

    Tournaments are simulated by randomly assigning a result to each game. The possible results are a win for white, a
    draw or a win for black with each occurring with equal likelihood. Additionally, there is a chance of a game being
    declared a forfeit win for either side or even both sides.
    """

    def __init__(
        self,
        client_1: type[PairingEngineClient],
        client_2: type[PairingEngineClient],
        tmp_path: Path,
        forfeit_ratio: float,
    ) -> None:
        """Initialize a new pairing engine comparer with the given chance of a game being declared a forfeit."""
        super().__init__(client_1, client_2, tmp_path)
        self.forfeit_ratio: float = forfeit_ratio

    def _get_random_result(self) -> tuple[ResultToken, ResultToken]:
        """Return a random pair of result tokens; (win, loss), (draw, draw), (loss, win), or some form of forfeit."""
        if random.random() > self.forfeit_ratio:
            return super()._get_random_result()

        match random.randint(0, 2):
            case 0:
                return ResultToken.FORFEIT_WIN, ResultToken.FORFEIT_LOSS
            case 1:
                return ResultToken.FORFEIT_LOSS, ResultToken.FORFEIT_WIN
            case _:
                return ResultToken.FORFEIT_LOSS, ResultToken.FORFEIT_LOSS


class RandomResultsComparerWithByes(RandomResultsComparer):
    """
    Callable class for comparing pairing engine clients for tournaments with purely random game results.

    Tournaments are simulated by randomly assigning a result to each game. The possible results are a win for white, a
    draw or a win for black with each occurring with equal likelihood. Additionally, in each round there is a chance of
    some players being assigned some form of bye.
    """

    def __init__(
        self,
        client_1: type[PairingEngineClient],
        client_2: type[PairingEngineClient],
        tmp_path: Path,
        bye_ratio: float,
    ) -> None:
        """Initialize a new pairing engine comparer with the given chance players being assigned a bye in any round."""
        super().__init__(client_1, client_2, tmp_path)
        self.bye_ratio: float = bye_ratio

    def _get_random_bye(self) -> ResultToken | None:
        """Randomly decide whether to return a uniformly chosen bye."""
        if random.random() > self.bye_ratio:
            return None

        match random.randint(0, 2):
            case 0:
                return ResultToken.HALF_POINT_BYE
            case 1:
                return ResultToken.FULL_POINT_BYE
            case _:
                return ResultToken.ZERO_POINT_BYE

    def _add_byes(self, trf: ParsedTrf) -> None:
        """Randomly assign byes to the players."""
        players = trf.player_sections
        score_system = trf.x_section.scoring_point_system
        byes = [self._get_random_bye() for _ in range(len(players))]

        for player, bye in zip(players, byes, strict=True):
            if not bool(player.results) or bye is None:
                continue
            round_result = RoundResult(id=0, color=ColorToken.BYE_OR_NOT_PAIRED, result=bye)
            self._add_result(player, round_result, score_system)


class RandomResultsComparerWithShuffle(RandomResultsComparer):
    def _get_player_sections(self, n: int) -> list[PlayerSection]:
        """Return a list of players sections in a rondom order for the given number."""
        player_sections = super()._get_player_sections(n)
        random.shuffle(player_sections)
        return player_sections
