from abc import ABC, abstractmethod
from typing import Generic, TypeVar

from py4swiss.dynamicuint import DynamicUint

W = TypeVar("W")


class ComputerBase(Generic[W], ABC):
    def __init__(self, size: int, edge_weight: W) -> None: ...

    @abstractmethod
    def size(self) -> int: ...

    @abstractmethod
    def add_vertex(self) -> None: ...

    @abstractmethod
    def set_edge_weight(self, u: int, v: int, weight: W) -> None: ...

    @abstractmethod
    def compute_matching(self) -> None: ...

    @abstractmethod
    def get_matching(self) -> list[int]: ...


class ComputerBurstein(ComputerBase[int]):
    def __init__(self, size: int, edge_weight: int) -> None: ...
    def size(self) -> int: ...
    def add_vertex(self) -> None: ...
    def set_edge_weight(self, u: int, v: int, weight: int) -> None: ...
    def compute_matching(self) -> None: ...
    def get_matching(self) -> list[int]: ...


class ComputerDutchValidity(ComputerBase[int]):
    def __init__(self, size: int, edge_weight: int) -> None: ...
    def size(self) -> int: ...
    def add_vertex(self) -> None: ...
    def set_edge_weight(self, u: int, v: int, weight: int) -> None: ...
    def compute_matching(self) -> None: ...
    def get_matching(self) -> list[int]: ...


class ComputerDutchOptimality(ComputerBase[DynamicUint]):
    def __init__(self, size: int, edge_weight: DynamicUint) -> None: ...
    def size(self) -> int: ...
    def add_vertex(self) -> None: ...
    def set_edge_weight(self, u: int, v: int, weight: DynamicUint) -> None: ...
    def compute_matching(self) -> None: ...
    def get_matching(self) -> list[int]: ...
